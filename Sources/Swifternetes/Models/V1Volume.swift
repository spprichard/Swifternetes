//
// V1Volume.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation


/** Volume represents a named volume in a pod that may be accessed by any container in the pod. */

public struct V1Volume: Codable {

    public var awsElasticBlockStore: V1AWSElasticBlockStoreVolumeSource?
    public var azureDisk: V1AzureDiskVolumeSource?
    public var azureFile: V1AzureFileVolumeSource?
    public var cephfs: V1CephFSVolumeSource?
    public var cinder: V1CinderVolumeSource?
    public var configMap: V1ConfigMapVolumeSource?
    public var csi: V1CSIVolumeSource?
    public var downwardAPI: V1DownwardAPIVolumeSource?
    public var emptyDir: V1EmptyDirVolumeSource?
    public var fc: V1FCVolumeSource?
    public var flexVolume: V1FlexVolumeSource?
    public var flocker: V1FlockerVolumeSource?
    public var gcePersistentDisk: V1GCEPersistentDiskVolumeSource?
    public var gitRepo: V1GitRepoVolumeSource?
    public var glusterfs: V1GlusterfsVolumeSource?
    public var hostPath: V1HostPathVolumeSource?
    public var iscsi: V1ISCSIVolumeSource?
    /** Volume&#39;s name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names */
    public var name: String
    public var nfs: V1NFSVolumeSource?
    public var persistentVolumeClaim: V1PersistentVolumeClaimVolumeSource?
    public var photonPersistentDisk: V1PhotonPersistentDiskVolumeSource?
    public var portworxVolume: V1PortworxVolumeSource?
    public var projected: V1ProjectedVolumeSource?
    public var quobyte: V1QuobyteVolumeSource?
    public var rbd: V1RBDVolumeSource?
    public var scaleIO: V1ScaleIOVolumeSource?
    public var secret: V1SecretVolumeSource?
    public var storageos: V1StorageOSVolumeSource?
    public var vsphereVolume: V1VsphereVirtualDiskVolumeSource?

    public init(awsElasticBlockStore: V1AWSElasticBlockStoreVolumeSource?, azureDisk: V1AzureDiskVolumeSource?, azureFile: V1AzureFileVolumeSource?, cephfs: V1CephFSVolumeSource?, cinder: V1CinderVolumeSource?, configMap: V1ConfigMapVolumeSource?, csi: V1CSIVolumeSource?, downwardAPI: V1DownwardAPIVolumeSource?, emptyDir: V1EmptyDirVolumeSource?, fc: V1FCVolumeSource?, flexVolume: V1FlexVolumeSource?, flocker: V1FlockerVolumeSource?, gcePersistentDisk: V1GCEPersistentDiskVolumeSource?, gitRepo: V1GitRepoVolumeSource?, glusterfs: V1GlusterfsVolumeSource?, hostPath: V1HostPathVolumeSource?, iscsi: V1ISCSIVolumeSource?, name: String, nfs: V1NFSVolumeSource?, persistentVolumeClaim: V1PersistentVolumeClaimVolumeSource?, photonPersistentDisk: V1PhotonPersistentDiskVolumeSource?, portworxVolume: V1PortworxVolumeSource?, projected: V1ProjectedVolumeSource?, quobyte: V1QuobyteVolumeSource?, rbd: V1RBDVolumeSource?, scaleIO: V1ScaleIOVolumeSource?, secret: V1SecretVolumeSource?, storageos: V1StorageOSVolumeSource?, vsphereVolume: V1VsphereVirtualDiskVolumeSource?) {
        self.awsElasticBlockStore = awsElasticBlockStore
        self.azureDisk = azureDisk
        self.azureFile = azureFile
        self.cephfs = cephfs
        self.cinder = cinder
        self.configMap = configMap
        self.csi = csi
        self.downwardAPI = downwardAPI
        self.emptyDir = emptyDir
        self.fc = fc
        self.flexVolume = flexVolume
        self.flocker = flocker
        self.gcePersistentDisk = gcePersistentDisk
        self.gitRepo = gitRepo
        self.glusterfs = glusterfs
        self.hostPath = hostPath
        self.iscsi = iscsi
        self.name = name
        self.nfs = nfs
        self.persistentVolumeClaim = persistentVolumeClaim
        self.photonPersistentDisk = photonPersistentDisk
        self.portworxVolume = portworxVolume
        self.projected = projected
        self.quobyte = quobyte
        self.rbd = rbd
        self.scaleIO = scaleIO
        self.secret = secret
        self.storageos = storageos
        self.vsphereVolume = vsphereVolume
    }


}

